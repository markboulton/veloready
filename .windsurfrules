# VeloReady iOS App - Windsurf Rules

## Project Context
iOS cycling performance tracking app built with SwiftUI
- Minimum iOS: 26.0
- Language: Swift
- Architecture: MVVM + Services
- Testing: VeloReadyCore Swift Package (40 tests, 9s execution)

## üß™ Testing Architecture

### VeloReadyCore Swift Package
All business logic MUST be testable without iOS simulator.

What belongs in VeloReadyCore:
- Cache management (CacheManager actor)
- Training load calculations (CTL/ATL/TSB)
- Strain/Recovery/Sleep calculations
- Data models and validation
- NO SwiftUI views, NO UIKit, NO UI-dependent ViewModels

Running Tests:
cd VeloReadyCore && swift run VeloReadyCoreTests  # 9 seconds
./Scripts/quick-test.sh  # Full suite, 90 seconds

Contract Testing: Update fixtures quarterly with ./Scripts/record-api-fixtures.sh (3-5 API calls). Tests use fixtures (0 API calls).

## ‚ö° Performance Architecture

### Startup: <2 Second Target

3-Phase Loading:
1. Phase 1 (0-200ms): Show cached data immediately, no blocking spinner
2. Phase 2 (200ms-2s): Update scores in parallel, animate changes
3. Phase 3 (2s-10s): Background sync, incremental loading

ANTI-PATTERNS:
// ‚ùå WRONG: Blocking full-screen spinner
.overlay {
    if isLoading { ProgressView() }  // Blocks for 8+ seconds!
}

// ‚úÖ CORRECT: Show cached, update in background
await showCachedScores()  // <100ms
Task.detached { await updateCriticalScores() }

### Cache Strategy

UnifiedCacheManager (Actor-based):
// ‚úÖ CORRECT: Actor for thread safety
public actor CacheManager {
    func fetch<T>(key: String, ttl: TimeInterval, operation: () async throws -> T)
}

// ‚ùå WRONG: Non-thread-safe
class CacheManager {
    var cache: [String: Any] = [:]  // Race conditions!
}

Cache Key Format (STRICT):
// ‚úÖ CORRECT
"strava:activities:365"
"score:recovery:2025-10-29T00:00:00Z"
"baselines:7day"
"stream:strava_12345"

// ‚ùå WRONG: Inconsistent formats cause cache misses
"strava_activities_365d"
"recovery-2025-10-29"

Cache TTLs:
- Stream data: 7 days
- Training load: 1 hour
- Baselines (HRV/RHR/Sleep 7-day avg): 1 hour
- Activity list: 15 minutes
- Scores: 48 hours

### Deduplication Pattern

// ‚úÖ CORRECT: Deduplicate simultaneous requests
private var calculationTasks: [String: Task<Int?, Never>] = [:]

func calculateScore(type: String) async -> Int? {
    if let existing = calculationTasks[type] {
        return await existing.value
    }
    
    let task = Task {
        defer { calculationTasks[type] = nil }
        return await performCalculation(type)
    }
    
    calculationTasks[type] = task
    return await task.value
}

// ‚ùå WRONG: Allow duplicate calculations
func calculateScore() async {
    await heavyCalculation()  // Multiple calls run in parallel!
}

### Race Condition Handling

// ‚úÖ CORRECT: Smart waiting for dependencies
if sleepScoreService.currentSleepScore == nil {
    if sleepScoreService.isLoading {
        // Sleep already running - WAIT for it
        var attempts = 0
        while sleepScoreService.isLoading && attempts < 50 {
            try? await Task.sleep(nanoseconds: 100_000_000)
            attempts += 1
        }
    } else {
        // Sleep not started - START it and wait
        await sleepScoreService.calculateSleepScore()
    }
}

// ‚ùå WRONG: Parallel execution without coordination
async let recovery = calculateRecovery()  // Needs sleep score!
async let sleep = calculateSleep()
// Recovery proceeds without sleep ‚Üí "Limited Data" bug

## üé® Design System (STRICT)

### Atomic Components
Use existing components, DO NOT recreate:
- CardContainer - Base card wrapper (NO external padding!)
- CardHeader, CardMetric, CardFooter
- ChartCard, ScoreCard, MetricStatCard
- VRBadge, VRText
- StandardCard - Detail view cards (NO external padding!)

### Design Tokens (NO Hard-Coding)

Spacing:
// ‚úÖ CORRECT
.padding(Spacing.md)      // 12pt
.padding(.horizontal, Spacing.xl)  // 24pt
VStack(spacing: Spacing.sm)  // 8pt

// ‚ùå WRONG
.padding(12)
.padding(.horizontal, 24)
VStack(spacing: 8)

Colors:
// ‚úÖ CORRECT
ColorScale.greenAccent
ColorScale.powerColor
ColorScale.hrvColor

// ‚ùå WRONG
Color(red: 0.2, green: 0.8, blue: 0.3)
Color.green

Content (Localization-ready):
// ‚úÖ CORRECT
VRText(CommonContent.loading, style: .body)
TodayContent.recoveryTitle

// ‚ùå WRONG
Text("Loading...")
Text("Recovery")

### Card Spacing Pattern (CRITICAL)

// ‚úÖ CORRECT: Parent controls spacing, cards have NO external padding
LazyVStack(spacing: Spacing.md) {  // 12pt between cards
    MyCardV2()
    AnotherCardV2()
}
.padding(.horizontal, Spacing.xl)  // 24pt on sides
.padding(.bottom, 120)              // 120pt at bottom

// Card implementation
struct MyCardV2: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // content
        }
        .padding(Spacing.md)  // INTERNAL padding only
        // ‚ùå NO .padding(.horizontal) or .padding(.vertical) here!
    }
}

// ‚ùå WRONG: Card adds external padding (causes double spacing!)
struct MyCard: View {
    var body: some View {
        VStack { ... }
        .padding(Spacing.md)
        .padding(.horizontal, Spacing.sm)  // ‚ùå WRONG!
        .padding(.vertical, Spacing.xxl / 2)  // ‚ùå WRONG!
    }
}

## üîê Authentication

JWT-based authentication with backend:
// ‚úÖ CORRECT: Use SupabaseClient for JWT tokens
let token = await supabaseClient.accessToken
headers["Authorization"] = "Bearer \(token)"

// ‚ùå WRONG: Hardcoded credentials
let athleteId = 104662  // NEVER DO THIS

Token refresh:
- Automatic when token expires in <5 minutes
- iOS calls backend /auth-refresh-token endpoint
- New tokens stored in SupabaseClient

## üêõ Common Pitfalls

1. Cache Key Inconsistency (Original Strava Bug)
// ‚ùå WRONG: Different keys for same data
let key1 = "strava_activities_365d"
let key2 = "strava:activities:365"  // Cache miss!

// ‚úÖ CORRECT: Use consistent format
extension CacheKey {
    static func stravaActivities(days: Int) -> String {
        "strava:activities:\(days)"
    }
}

2. Non-Thread-Safe Cache
// ‚ùå WRONG
class CacheManager {
    var cache: [String: Any] = [:]  // Race conditions!
}

// ‚úÖ CORRECT
public actor CacheManager {
    private var cache: [String: Any] = [:]
}

3. Full-Screen Blocking Spinner
// ‚ùå WRONG: Blocks UI for 8+ seconds
.overlay {
    if isLoading { ProgressView() }
}

// ‚úÖ CORRECT: Show UI immediately
await showCachedScores()
Task.detached { await updateScores() }

4. Duplicate Calculations
// ‚ùå WRONG
await calculateRecovery()  // Calculates TRIMP
await calculateStrain()     // Calculates TRIMP again! (4-6s wasted)

// ‚úÖ CORRECT
if !hasCalculatedToday {
    await calculateRecovery()
}

5. Alcohol Detection During Illness
// ‚ùå WRONG: Penalize for alcohol when sick
let penalty = detectAlcohol(hrv, rhr, sleep)

// ‚úÖ CORRECT: Check illness first
if let illness = illnessIndicator {
    return baseScore  // Skip alcohol detection
}

6. Fetching Too Much Data on Startup
// ‚ùå WRONG
let activities = await fetchActivities(days: 365)  // 5+ seconds!

// ‚úÖ CORRECT: Fetch incrementally
let today = await fetchActivities(days: 1)  // <1s
Task.detached(priority: .background) {
    await fetchActivities(days: 365)
}

7. Imports Not at Top
// ‚ùå WRONG
struct MyView: View {
    import Foundation  // SYNTAX ERROR!
}

// ‚úÖ CORRECT
import SwiftUI
import Foundation
import VeloReadyCore

struct MyView: View { ... }

## üìù File Organization

VeloReadyCore/              # Testable business logic
‚îú‚îÄ‚îÄ Sources/
‚îÇ   ‚îú‚îÄ‚îÄ VeloReadyCore.swift           # Cache manager (actor)
‚îÇ   ‚îú‚îÄ‚îÄ TrainingLoadCalculations.swift
‚îÇ   ‚îú‚îÄ‚îÄ StrainCalculations.swift
‚îÇ   ‚îú‚îÄ‚îÄ RecoveryCalculations.swift
‚îÇ   ‚îú‚îÄ‚îÄ SleepCalculations.swift
‚îÇ   ‚îú‚îÄ‚îÄ ZoneCalculations.swift
‚îÇ   ‚îî‚îÄ‚îÄ Models/
‚îÇ       ‚îî‚îÄ‚îÄ ActivityData.swift
‚îî‚îÄ‚îÄ Tests/
    ‚îî‚îÄ‚îÄ VeloReadyCoreTests.swift      # 40 tests, 9s execution

Core/
‚îú‚îÄ‚îÄ Services/                         # Service layer
‚îÇ   ‚îú‚îÄ‚îÄ StreamCacheService.swift      # 7-day stream cache
‚îÇ   ‚îú‚îÄ‚îÄ RecoveryScoreService.swift
‚îÇ   ‚îú‚îÄ‚îÄ SleepScoreService.swift
‚îÇ   ‚îî‚îÄ‚îÄ HealthKitManager.swift
‚îî‚îÄ‚îÄ Networking/
    ‚îú‚îÄ‚îÄ VeloReadyAPIClient.swift      # Backend API (JWT auth)
    ‚îî‚îÄ‚îÄ IntervalsAPIClient.swift

DesignSystem/
‚îú‚îÄ‚îÄ Tokens/                           # Design tokens
‚îÇ   ‚îú‚îÄ‚îÄ Spacing.swift
‚îÇ   ‚îú‚îÄ‚îÄ ColorScale.swift
‚îÇ   ‚îî‚îÄ‚îÄ Icons.swift
‚îú‚îÄ‚îÄ Components/                       # Atomic components
‚îÇ   ‚îú‚îÄ‚îÄ CardContainer.swift
‚îÇ   ‚îú‚îÄ‚îÄ VRText.swift
‚îÇ   ‚îî‚îÄ‚îÄ VRBadge.swift
‚îî‚îÄ‚îÄ Content/                          # Localized strings
    ‚îú‚îÄ‚îÄ CommonContent.swift
    ‚îî‚îÄ‚îÄ TodayContent.swift

Features/
‚îî‚îÄ‚îÄ Today/
    ‚îú‚îÄ‚îÄ Views/
    ‚îú‚îÄ‚îÄ ViewModels/
    ‚îî‚îÄ‚îÄ Cards/                        # V2 migrated cards

Scripts/
‚îú‚îÄ‚îÄ quick-test.sh                     # Local full test suite
‚îî‚îÄ‚îÄ record-api-fixtures.sh            # Update contract test fixtures

Tests/
‚îî‚îÄ‚îÄ Fixtures/                         # Contract test fixtures
    ‚îú‚îÄ‚îÄ strava_activities_response.json
    ‚îî‚îÄ‚îÄ intervals_activities_response.json

## üöÄ Development Workflow

Before Committing:
cd VeloReadyCore && swift run VeloReadyCoreTests  # 9 seconds
./Scripts/quick-test.sh  # 90 seconds
xcodebuild -scheme VeloReady build

Adding New Features:
1. Business logic ‚Üí VeloReadyCore/Sources/
2. Tests ‚Üí VeloReadyCore/Tests/
3. UI ‚Üí Use atomic components from DesignSystem/
4. Verify tests pass locally

Quarterly Maintenance:
export STRAVA_TOKEN="your_token"
./Scripts/record-api-fixtures.sh  # 3-5 API calls
swift run VeloReadyCoreTests
git diff Tests/Fixtures/

## ‚úÖ Code Quality Checklist

Before submitting PR:
- [ ] Business logic added to VeloReadyCore (if applicable)
- [ ] Tests added/updated in VeloReadyCore/Tests/
- [ ] Used atomic components (no custom card implementations)
- [ ] Used design tokens (NO hard-coded spacing/colors/strings)
- [ ] Cards have NO external padding
- [ ] Cache keys use consistent format
- [ ] Actor isolation for shared state
- [ ] Imports at top of file
- [ ] Tests pass locally (./Scripts/quick-test.sh)

## üìä Performance Targets

| Metric | Target | Current |
|--------|--------|---------|
| Startup (cached) | <200ms | ‚úÖ ~150ms |
| Startup (fresh) | <2s | ‚úÖ ~1.8s |
| Core tests | <10s | ‚úÖ 9s |
| Full tests | <120s | ‚úÖ 90s |
| API quota/test | 0 | ‚úÖ 0 |
| Cache hit rate | >80% | ‚úÖ ~85% |
| Stream load (cached) | <500ms | ‚úÖ ~400ms |

## üéØ Key Principles

1. Test business logic independently - VeloReadyCore enables this
2. Progressive enhancement - Show UI fast, update in background
3. Cache aggressively - But with proper TTLs and invalidation
4. Deduplicate requests - No duplicate calculations
5. Handle race conditions - Smart waiting for dependencies
6. Design system compliance - Use tokens, atomic components
7. Performance conscious - <2s startup, incremental loading